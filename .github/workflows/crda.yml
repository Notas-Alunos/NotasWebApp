name: CRDA Scan

on:
  workflow_call:
    secrets:
      CRDA_KEY:
        required: false
      SNYK_TOKEN:
        required: false
  workflow_dispatch:
  pull_request_target:
    branches: [ "main" ]
    types: [opened, synchronize, reopened, labeled, edited]

permissions:
  contents: read
  security-events: write
  issues: write
  pull-requests: write

jobs:
  crda-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      issues: write
      pull-requests: write

    steps:
      # 1) Gate: exige rótulo de aprovação
      - name: Gate — exigir label de aprovação
        id: gate
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const approvedLabels = ['ok-to-scan', 'CRDA Scan Approved'];
            const { owner, repo } = context.repo;
            const n = context.issue.number;

            const { data } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: n
            });
            const has = data.some(l => approvedLabels.includes(l.name));

            core.setOutput('approved', has ? 'true' : 'false');

            if (!has) {
              await github.rest.issues.createComment({
                owner, repo, issue_number: n,
                body:
                  `⚠️ Segurança: adicione o label **${approvedLabels.join('** ou **')}** para autorizar o scan com secrets.\n\n` +
                  `> Dica: mantenedores podem aplicar esse label quando o PR for confiável.`
              });
            }

      # 2) Checkout do HEAD do PR (inclusive forks)
      - name: Check out PR HEAD (após aprovação)
        if: steps.gate.outputs.approved == 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          persist-credentials: false

      # 3) Workaround: garantir que não é detached HEAD (evita erro no cleanup do CRDA)
      - name: Ensure non-detached HEAD for CRDA cleanup
        if: steps.gate.outputs.approved == 'true'
        run: |
          git checkout -B crda-pr-${{ github.event.pull_request.number }} ${{ github.event.pull_request.head.sha }}
          echo "Current branch: $(git branch --show-current)"

      # 4) Instalar a CLI do CRDA
      - name: Install CRDA CLI
        if: steps.gate.outputs.approved == 'true'
        uses: redhat-actions/openshift-tools-installer@144527c7d98999f2652264c048c7a9bd103f8a82
        with:
          source: github
          github_pat: ${{ github.token }}
          crda: "latest"

      # 5) Rodar o CRDA apenas se existir manifest suportado
      - name: CRDA Scan
        if: steps.gate.outputs.approved == 'true' && hashFiles('**/pom.xml','**/package.json','**/yarn.lock','**/requirements.txt','**/go.mod') != ''
        id: crda
        uses: redhat-actions/crda@6310ee94a6ac8f76b4152b7267c6cd7f1277052c
        with:
          # Use UM dos dois segredos abaixo:
          crda_key: ${{ secrets.CRDA_KEY }}
          # snyk_token: ${{ secrets.SNYK_TOKEN }}
          # upload_artifact: false

      # 6) Aviso: sem manifest — CRDA ignorado
      - name: Informar que CRDA foi ignorado (sem manifest)
        if: steps.gate.outputs.approved == 'true' && steps.crda.outcome == ''
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const { owner, repo } = context.repo;
            const n = context.issue.number;
            await github.rest.issues.createComment({
              owner, repo, issue_number: n,
              body: "ℹ️ CRDA **ignorado**: nenhum manifest suportado encontrado (`pom.xml`, `package.json`, `yarn.lock`, `requirements.txt` ou `go.mod`)."
            });

      # 7) Comentário final de status
      - name: Comentar status no PR
        if: always() && steps.gate.outputs.approved == 'true'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |
            const { owner, repo } = context.repo;
            const n = context.issue.number;
            const outcome = '${{ job.status }}';
            const msg = outcome === 'success'
              ? '✅ CRDA scan concluído. Veja **Security → Code scanning alerts**.'
              : '❌ CRDA scan falhou. Verifique os logs em **Actions**.';
            await github.rest.issues.createComment({ owner, repo, issue_number: n, body: msg });
